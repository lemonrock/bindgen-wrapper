#!/usr/bin/env sh
# This file is part of bindgen-wrapper. It is subject to the license terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/bindgen-wrapper/master/COPYRIGHT. No part of bindgen-wrapper, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2016 The developers of bindgen-wrapper. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/bindgen-wrapper/master/COPYRIGHT.


set -e
set -u
set -f


_program_path_find()
{
    if [ "${_program_fattening_program_path+set}" = 'set' ]; then
        printf '%s\n' "$_program_fattening_program_path"

    elif [ "${0%/*}" = "$0" ]; then

        # We've been invoked by the interpreter as, say, bash program
        if [ -r "$0" ]; then
            pwd -P
        # Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
        else
            printf '\n'
        fi

    else

        # We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

        _program_path_find_parentPath()
        {
            parentPath="${scriptPath%/*}"
            if [ -z "$parentPath" ]; then
                parentPath='/'
            fi
            cd "$parentPath" 1>/dev/null
        }

        # pdksh / mksh have problems with unsetting a variable that was never set...
        if [ "${CDPATH+set}" = 'set' ]; then
            unset CDPATH
        fi

        if command -v realpath 1>/dev/null 2>/dev/null; then
            (
                scriptPath="$(realpath "$0")"

                _program_path_find_parentPath
                pwd -P
            )
        elif command -v readlink 1>/dev/null 2>/dev/null; then
            (
                scriptPath="$0"

                while [ -L "$scriptPath" ]
                do
                    _program_path_find_parentPath
                    scriptPath="$(readlink "$scriptPath")"
                done

                _program_path_find_parentPath
                pwd -P
            )
        else
            # This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
            (
                scriptPath="$0"

                _program_path_find_parentPath
                pwd -P
            )
        fi

    fi
}

bindgen_wrapper_fail()
{
	local failureMessage="$1"
	
	printf '%s\n' "$failureMessage" 1>&2
	exit 1
}

bindgen_wrapper_isAlpineLinuxIfIsLinux()
{
	command -v apk 1>/dev/null 2>/dev/null
}

bindgen_wrapper_ensureRequiredBinariesArePresent()
{
	local reason="$1"
	shift 1
	
	local binary
	local missing=false
	for binary in "$@"
	do
		if ! command -v "$binary" 1>/dev/null 2>/dev/null; then
			printf '%s\n' "The binary '$binary' needs to be in the path" 1>&2
			missing=true
		fi
	done
	
	if $missing; then
		bindgen_wrapper_fail "Please make sure that the missing binaries are installed because '$reason'"
	fi
}

bindgen_wrapper_cargoBinaryInstall()
{
	local crate="$1"
	shift 1

	if command -v "$crate" 1>/dev/null 2>/dev/null; then
		return 0
	fi
		
	bindgen_wrapper_ensureRequiredBinariesArePresent "To check for, and, if necessary, install the cargo binary '$crate'" cargo grep awk
	
	if cargo install --list | grep -v '^ ' | awk '{ print $1 }' | grep -q '^'"$crate"'$'; then
		return 0
	fi
	
	cargo install "$@" "$crate"
	
	if ! command -v "$crate" 1>/dev/null 2>/dev/null; then
		bindgen_wrapper_fail "Please make sure that binaries installed by 'cargo' (such as '$crate') are in your PATH"
	fi
}

_bindgen_wrapper_macosxHomebrewOrAlipineLinuxPackageManagerYetToBeUpdated=true

bindgen_wrapper_macosxHomebrewInstall()
{
	local package="$1"
	shift 1
		
	bindgen_wrapper_ensureRequiredBinariesArePresent "To check for and, if necessary, install the brew package '$package'" brew grep
	
	# Sadly, this can not check --with-shared-libs
	if brew list | grep -q "$package"; then
		return 0
	fi
	
	if $_bindgen_wrapper_macosxHomebrewOrAlipineLinuxPackageManagerYetToBeUpdated; then
		brew update
		brew upgrade
		_bindgen_wrapper_macosxHomebrewOrAlipineLinuxPackageManagerYetToBeUpdated=false
	fi
	
	brew install "$package" "$@"
}

bindgen_wrapper_alpineLinuxInstall()
{
	local package="$1"
	shift 1
	
	bindgen_wrapper_ensureRequiredBinariesArePresent "To check for the apk package '$package'" apk
	
	if ! apk info --installed "$package" 1>/dev/null 2>/dev/null; then
		bindgen_wrapper_ensureRequiredBinariesArePresent "To check for and, if necessary, install the apk package '$package' as root" sudo
		
		if $_bindgen_wrapper_macosxHomebrewOrAlipineLinuxPackageManagerYetToBeUpdated; then
			sudo -p "Enter your password to call apk update before installing package '$package': " apk update
			sudo -p "Enter your password to call apk upgrade before installing package '$package': "  apk upgrade
			_bindgen_wrapper_macosxHomebrewOrAlipineLinuxPackageManagerYetToBeUpdated=false
		fi
		
		sudo -p "Enter your password to call apk add to install package '$package' (you may need to enable edge and testing repositories in /etc/apk/repositories): " apk add "$package"
	fi
}

bindgen_wrapper_installBindgen()
{
	local libclangPath="$llvmPrefix"/lib
	if [ "$platform" = 'Linux' ]; then
		if bindgen_wrapper_isAlpineLinuxIfIsLinux; then
			rm -rf "$_program_path"/libclang.so
			ln -s /usr/lib/libclang.so.3.8 "$_program_path"/libclang.so
			libclangPath="$_program_path"
		fi
	fi
	
	LLVM_CONFIG_PATH="$llvmPrefix"/bin/llvm-config \
	LIBCLANG_PATH="$libclangPath" \
	LIBCLANG_STATIC_PATH="$llvmPrefix"/lib \
		bindgen_wrapper_cargoBinaryInstall bindgen
}

bindgen_wrapper_installHeadersAndCopyOverrides()
{
	rm -rf "$temporaryIncludeFolder"
	mkdir -m 0755 -p "$temporaryIncludeFolder"
	rsync --quiet --archive "$configurationFolderPath"/header-overrides/ "$headersFolderPath"/ "$temporaryIncludeFolder"/
}

bindgen_wrapper_createOutputFolder()
{
	local outputFolderPath="${outputFilePath%/*}"
	rm -rf "$outputFolderPath"
	mkdir -m 0755 -p "$outputFolderPath"
}

bindgen_wrapper_addTacFallbackIfNotPresent()
{
	# Note: tac does not exist on Mac OS X
	if ! command -v tac 1>/dev/null 2>/dev/null; then
		bindgen_wrapper_ensureRequiredBinariesArePresent "Required because 'tac' binary is not present" tail
		tac()
		{
			tail -r -- "$@"
		}
	fi
}

bindgen_wrapper_bindgen()
{
	# clangAdditionalArguments deliberately has quotes ommitted
	set -- "$@" \
		--convert-macros \
		--macro-int-types=sint,sint,sint,slonglong,sint,sint,sint,slonglong \
		--use-core \
		--ctypes-prefix=XXX \
		"$temporaryIncludeFolder"/"$rootIncludeFileName" -- -I"$temporaryIncludeFolder" $clangAdditionalArguments
	
	case "$platform" in
		
		Darwin)
			"$_program_path"/bindgen-macosx "$@" -U__BLOCKS__
		;;
		
		*)
			CLANG_PATH="$llvmPrefix"/bin/clang ~/.cargo/bin/bindgen "$@"
		;;
		
	esac
}

bindgen_wrapper_installPrerequisites()
{
	# Platform specific installation of dependencies
	local packagesToInstall
	local packageInstallFunction
	case "$platform" in
		
		Darwin)
			bindgen_wrapper_macosxHomebrewInstall llvm --with-shared-libs --with-all-targets
			
			packageInstallFunction=bindgen_wrapper_macosxHomebrewInstall
			packagesToInstall="$macosXHomebrewPackageNames"
		;;
		
		Linux)
			if [ -d ~/.cargo/bin ]; then
				export PATH=~/.cargo/bin:"$PATH"
			fi
			
			if bindgen_wrapper_isAlpineLinuxIfIsLinux; then
				bindgen_wrapper_alpineLinuxInstall llvm
				bindgen_wrapper_alpineLinuxInstall llvm-static
				bindgen_wrapper_alpineLinuxInstall llvm-dev
				bindgen_wrapper_alpineLinuxInstall llvm-libs
				bindgen_wrapper_alpineLinuxInstall clang-libs
				bindgen_wrapper_alpineLinuxInstall clang
				bindgen_wrapper_alpineLinuxInstall clang-dev
			
				# Provides C library headers
				bindgen_wrapper_alpineLinuxInstall musl-dev
				
				# Provides Rust
				bindgen_wrapper_alpineLinuxInstall rust
				bindgen_wrapper_alpineLinuxInstall cargo
			
				packageInstallFunction=bindgen_wrapper_alpineLinuxInstall
				packagesToInstall="$alpineLinuxPackageNames"
			else
				local hasRustC
				if command -v rustc 1>/dev/null 2>/dev/null; then
					hasRustC=true
				else
					hasRustC=false
				fi
				
				local hasCargo
				if command -v cargo 1>/dev/null 2>/dev/null; then
					hasCargo=true
				else
					hasCargo=false
				fi
				
				if $hasRustC; then
					if $hasCargo; then
						:
					else
						bindgen_wrapper_fail "rustc is in the PATH but not cargo; this is an unsupported combination"
					fi
				else
					if $hasCargo; then
						bindgen_wrapper_fail "cargo is in the PATH but not rustc; this is an unsupported combination"
					else
						bindgen_wrapper_ensureRequiredBinariesArePresent "Required to install rust and cargo using rustup" curl sh
						curl https://sh.rustup.rs -sSf | sh
					fi
				fi
			fi
		;;
		
	esac
	
	local IFS=' '
	local localPackageManagerPackage
	# quotes deliberately ommitted
	for localPackageManagerPackage in $packagesToInstall
	do
		$packageInstallFunction "$localPackageManagerPackage"
	done
	
	bindgen_wrapper_cargoBinaryInstall rustfmt
	bindgen_wrapper_installBindgen
}

bindgen_wrapper_prepend()
{
	local fileToPrepend
	for fileToPrepend in "$configurationFolderPath"/preamble.rs "$_program_path"/includes.rs "$configurationFolderPath"/post-includes.rs
	do
		if [ -s "$fileToPrepend" ]; then
			cat "$fileToPrepend"
			printf '\n'
		fi
	done
		
	local IFS=' '
	local linkValue
	# quotes deliberately ommitted
	for linkValue in $link
	do
		cat <<-EOF
			
			#[link(name = "${linkValue}")]
			extern "C"
			{
			}
		EOF
	done
}

bindgen_wrapper_rawGeneration()
{
	# Scope of bindings
	cd "$temporaryIncludeFolder" 1>/dev/null 2>/dev/null
	
		set --
		local wantedHeaderFile
		set +f
		for wantedHeaderFile in *.h
		do
			set -f
			set -- "$@" --match="$wantedHeaderFile"
		done
		set -f
	
	cd - 1>/dev/null 2>/dev/null
	
	bindgen_wrapper_bindgen "$@"
}

bindgen_wrapper_cleanedGeneration()
{
	local newline='\'$'\n'
	
	# sed line explanations:-
	# 1 - remove bindgen comment
	# 2 - remove multiline allow that (a) rustfmt can't format and (b) is no longer the first item in the file because of the use statements above and (c) is overly broad
	# 3 to 7 - remove prefixes in favour of use statements above for readability
	# 8 - suppress Copy warnings for empty enums which are types for opaque structs, format them (rustfmt can't)
	sed \
		-e '/automatically generated by rust-bindgen/d' \
		-e '/#!\[allow(dead_code,/,/non_snake_case/d' \
		-e 's/::XXX:://g' \
		-e 's/::core::clone:://g' \
		-e 's/::core::option:://g' \
		-e 's/::core::mem:://g' \
		-e 's/::core::default:://g' \
		-e 's/^pub enum \(.*\) { }/#[allow(missing_copy_implementations)]'"$newline"'#[derive(Debug)]'"$newline"'pub enum \1'"$newline"'{'"$newline"'}/g'
}

bindgen_wrapper_rustfmt()
{
	local newline='\'$'\n'
	
	# sed line explanations-
	# 1 - add newline before '{' in an extern block (rustfmt can't)
	# 2 - add newline before '{' in an empty enum (rustfmt can't)
	# 3 - space out better
	~/.cargo/bin/rustfmt --config-path "$_program_path"/.. | \
	sed \
		-e 's/^extern "C" {/extern "C"'"$newline"'{/g' \
		-e 's/^pub enum \(.*\) {/pub enum \1'"$newline"'{/g' \
		-e 's/^}$/}'"$newline"'/g' -e 's/^pub type \(.*\)$/pub type \1'"$newline"'/g'
}

bindgen_wrapper_generate()
{
	local temporaryIncludeFolder="$_program_path"/temporary
	
	bindgen_wrapper_installHeadersAndCopyOverrides
	
	bindgen_wrapper_createOutputFolder

	bindgen_wrapper_prepend >"$outputFilePath".prepend
	
	bindgen_wrapper_rawGeneration >"$outputFilePath".rawGeneration
	
	cat "$outputFilePath".rawGeneration | bindgen_wrapper_cleanedGeneration >"$outputFilePath".cleanedGeneration
	
	cat "$outputFilePath".cleanedGeneration | postprocess_after_generation >"$outputFilePath".afterGeneration
	
	cat "$outputFilePath".afterGeneration | bindgen_wrapper_rustfmt >"$outputFilePath".rustfmt
	
	cat "$outputFilePath".rustfmt | postprocess_after_rustfmt >"$outputFilePath".afterRustfmt
	
	# {
	# 	cat "$outputFilePath".prepend
	# 	cat "$outputFilePath".afterRustfmt
	# } >"$outputFilePath"
	
	grep -v '^pub const ' "$outputFilePath".afterRustfmt >"$outputFilePath".withoutConstants

	grep -v '^pub type ' "$outputFilePath".withoutConstants >"$outputFilePath".withoutConstantsWithoutTypes
	
	local namedFile=''
	local name=''	
	local attributes=''
	local mode='next'
	local externC='ExpectingPubStaticMut'
	while IFS='' read -r line
	do
		case "$mode" in
			
			next)
		
				case "$line" in
			
					'')
						continue
					;;
			
					'#'*)
						if [ -z "$attributes" ]; then
							attributes="$line"
						else
							attributes="${attributes}
${line}"
						fi
					;;
					
					'pub const '*)
						local stripPrefix="${line#pub const }"
						name="${stripPrefix%:*}"
						printf '%s\n' "$line" >>"$outputFolderPath"/constants
					;;
					
					'pub type '*)
						local stripPrefix="${line#pub type }"
						name="${stripPrefix% =*}"
						echo "Type: '$name'"
						printf 'include!("%s");\n' "$name".rs >>"$outputFolderPath"/types
						namedFile="$outputFolderPath"/"$name".rs
						{
							cat "$configurationFolderPath"/preamble.rs
							printf '%s\n' "$line"
						} >"$namedFile"
					;;
			
					'pub enum '*)
						name="${line#pub enum }"
						printf 'include!("%s");\n' "$name".rs >>"$outputFolderPath"/enums
						namedFile="$outputFolderPath"/"$name".rs
						{
							cat "$configurationFolderPath"/preamble.rs
							printf '%s\n' "$attributes"
							printf '%s\n' "$line"
						} >"$namedFile"
						attributes=''
						mode=openBrace
					;;

					'pub struct '*)
						name="${line#pub struct }"
						printf 'include!("%s");\n' "$name".rs >>"$outputFolderPath"/structs
						namedFile="$outputFolderPath"/"$name".rs
						{
							cat "$configurationFolderPath"/preamble.rs
							printf '%s\n' "$attributes"
							printf '%s\n' "$line"
						} >"$namedFile"
						attributes=''
						mode=openBrace
					;;
					
					'impl '*)
						printf '%s\n' "$line" >>"$namedFile"
						mode=openBrace
					;;
					
					'extern "C"')
					
						case "$externC" in
							
							ExpectingPubStaticMut)
								mode=openBracePubStaticMut
							;;
							
							ExpectingPubFn)
								mode=openBracePubFn
							;;
							
							*)
								bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode' when externC '$externC'"
							;;
						
						esac
					;;
					
					*)
						bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
					;;
				
				esac
			;;
			
			openBrace)
				if [ "$line" != '{' ]; then
					bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
				fi
				printf '%s\n' "$line" >>"$namedFile"
				mode=closeBrace
			;;
			
			closeBrace)
				if [ "$line" = '}' ]; then
					mode=next
				fi
				printf '%s\n\n' "$line" >>"$namedFile"
			;;
			
			openBracePubStaticMut)
				if [ "$line" != '{' ]; then
					bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
				fi
				mode=closeBracePubStaticMut
			;;
			
			closeBracePubStaticMut)
				if [ "$line" = '}' ]; then
					mode=next
					externC=ExpectingPubFn
				else
					printf '%s\n' "$line" >>"$outputFolderPath"/statics
				fi
			;;
			
			openBracePubFn)
				if [ "$line" != '{' ]; then
					bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
				fi
				mode=closeBracePubFn
			;;
			
			closeBracePubFn)
				if [ "$line" = '}' ]; then
					mode=next
				else
					printf '%s\n' "$line" >>"$outputFolderPath"/functions
				fi
			;;
			
			*)
				bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
			;;
			
		esac
		
	done <"$outputFilePath".afterRustfmt
	
	{
		bindgen_wrapper_prepend
	
		printf '\n\n// Constants\n'
		sort "$outputFolderPath"/constants
		rm -rf "$outputFolderPath"/constants
	
		printf '\n\n// Statics\n'
		printf 'extern "C"\n{\n'
		sort "$outputFolderPath"/statics
		rm -rf "$outputFolderPath"/statics
		printf '}\n'
	
		printf '\n\n// Functions\n'
		printf 'extern "C"\n{\n'
		sort "$outputFolderPath"/functions
		rm -rf "$outputFolderPath"/functions
		printf '}\n'
	
		printf '\n\n// Types\n'
		sort "$outputFolderPath"/types
		rm -rf "$outputFolderPath"/types
	
		printf '\n\n// Enums\n'
		sort "$outputFolderPath"/enums
		rm -rf "$outputFolderPath"/enums
	
		printf '\n\n// Structs\n'
		sort "$outputFolderPath"/structs
		rm -rf "$outputFolderPath"/structs
	} >"$outputFilePath"
}

bindgen_wrapper_buildCheck()
{
	cd "$_program_path"/.. 1>/dev/null 2>/dev/null
		
		cargo clean
		
		if ! cargo build; then
			bindgen_wrapper_fail "Make sure that Cargo.toml contains a dependency for libc, at least 0.2"
		fi
	
	cd - 1>/dev/null 2>/dev/null
	
	printf '\n\n%s\n\n\n' "***** Generated and Compiles *****"
}

bindgen_wrapper_sourceConfigurationThenExecute()
{
	local functionToExecute="$1"
	shift 1
	
	local configurationFolderPath="$homeFolder"/bindgen-wrapper.conf.d
	local configurationFilePath="$configurationFolderPath"/configuration.sh
	if [ ! -s "$configurationFilePath" ]; then
		bindgen_wrapper_fail "Configuration file '$configurationFilePath' is not present, not readable or empty"
	fi
	local bindingsName
	local rootIncludeFileName
	local link
	local macosXHomebrewPackageNames
	local alpineLinuxPackageNames
	local outputFolderPath="$homeFolder"/src
	local outputFilePath="$outputFolderPath"/lib.rs
	local headersFolderPath=''
	local clangAdditionalArguments=''
	preprocess_before_headersFolderPath()
	{
		cat
	}
	postprocess_after_generation()
	{
		cat
	}
	postprocess_after_rustfmt()
	{
		cat
	}
	. "$configurationFolderPath"/configuration.sh
	
	if [ -z "$headersFolderPath" ]; then
		headersFolderPath="$prefix"/include/"$bindingsName"
	fi
	
	$functionToExecute "$@"
}

bindgen_wrapper_execute()
{
	bindgen_wrapper_installPrerequisites
	preprocess_before_headersFolderPath
	bindgen_wrapper_generate
	bindgen_wrapper_buildCheck
}

bindgen_wrapper_setAbsoluteProgramPathAndHomeFolder()
{
	_program_path="$(_program_path_find)"
	cd "$_program_path"/../.. 1>/dev/null 2>/dev/null
		homeFolder="$(pwd -P)"
	cd - 1>/dev/null 2>/dev/null
}

bindgen_wrapper_main()
{
	bindgen_wrapper_ensureRequiredBinariesArePresent "Required for basic operation" uname rm mkdir cat sed sort grep
	
	bindgen_wrapper_setAbsoluteProgramPathAndHomeFolder
	
	# Platform variations that can be overridden by configuration
	local platform="$(uname)"
	case "$platform" in
		
		Darwin)
			bindgen_wrapper_ensureRequiredBinariesArePresent "Required for basic operation on Mac OS X" brew
			local prefix="$(brew --prefix)"
			local llvmPrefix="$(brew --prefix llvm)"
		;;
		
		Linux)
			local prefix='/usr'
			local llvmPrefix="$prefix"
		;;
		
		*)
			bindgen_wrapper_fail "Unsupported platform '$platform'"
		;;
		
	esac
	
	bindgen_wrapper_sourceConfigurationThenExecute bindgen_wrapper_execute
}

bindgen_wrapper_main "$@"
