#!/usr/bin/env sh
# This file is part of bindgen-wrapper. It is subject to the license terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/bindgen-wrapper/master/COPYRIGHT. No part of bindgen-wrapper, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2016 The developers of bindgen-wrapper. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/bindgen-wrapper/master/COPYRIGHT.


set -e
set -u
set -f


_program_path_find()
{
    if [ "${_program_fattening_program_path+set}" = 'set' ]; then
        printf '%s\n' "$_program_fattening_program_path"

    elif [ "${0%/*}" = "$0" ]; then

        # We've been invoked by the interpreter as, say, bash program
        if [ -r "$0" ]; then
            pwd -P
        # Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
        else
            printf '\n'
        fi

    else

        # We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

        _program_path_find_parentPath()
        {
            parentPath="${scriptPath%/*}"
            if [ -z "$parentPath" ]; then
                parentPath='/'
            fi
            cd "$parentPath" 1>/dev/null
        }

        # pdksh / mksh have problems with unsetting a variable that was never set...
        if [ "${CDPATH+set}" = 'set' ]; then
            unset CDPATH
        fi

        if command -v realpath 1>/dev/null 2>/dev/null; then
            (
                scriptPath="$(realpath "$0")"

                _program_path_find_parentPath
                pwd -P
            )
        elif command -v readlink 1>/dev/null 2>/dev/null; then
            (
                scriptPath="$0"

                while [ -L "$scriptPath" ]
                do
                    _program_path_find_parentPath
                    scriptPath="$(readlink "$scriptPath")"
                done

                _program_path_find_parentPath
                pwd -P
            )
        else
            # This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
            (
                scriptPath="$0"

                _program_path_find_parentPath
                pwd -P
            )
        fi

    fi
}

bindgen_wrapper_fail()
{
	local failureMessage="$1"

	printf '%s\n' "$failureMessage" 1>&2
	exit 1
}

bindgen_wrapper_isAlpineLinuxIfIsLinux()
{
	command -v apk 1>/dev/null 2>/dev/null
}

bindgen_wrapper_ensureRequiredBinariesArePresent()
{
	local reason="$1"
	shift 1

	local binary
	local missing=false
	for binary in "$@"
	do
		if ! command -v "$binary" 1>/dev/null 2>/dev/null; then
			printf '%s\n' "The binary '$binary' needs to be in the path" 1>&2
			missing=true
		fi
	done

	if $missing; then
		bindgen_wrapper_fail "Please make sure that the missing binaries are installed because '$reason'"
	fi
}

bindgen_wrapper_cargoBinaryInstall()
{
	local crate="$1"
	shift 1

	if command -v "$crate" 1>/dev/null 2>/dev/null; then
		return 0
	fi

	bindgen_wrapper_ensureRequiredBinariesArePresent "To check for, and, if necessary, install the cargo binary '$crate'" cargo grep awk

	if cargo install --list | grep -v '^ ' | awk '{ print $1 }' | grep -q '^'"$crate"'$'; then
		return 0
	fi

	cargo install "$@" "$crate"

	if ! command -v "$crate" 1>/dev/null 2>/dev/null; then
		bindgen_wrapper_fail "Please make sure that binaries installed by 'cargo' (such as '$crate') are in your PATH"
	fi
}

_bindgen_wrapper_macosxHomebrewOrAlipineLinuxPackageManagerYetToBeUpdated=true

bindgen_wrapper_macosxHomebrewInstall()
{
	local package="$1"
	shift 1

	bindgen_wrapper_ensureRequiredBinariesArePresent "To check for and, if necessary, install the brew package '$package'" brew grep

	# Sadly, this can not check --with-shared-libs
	if brew list | grep -q "$package"; then
		return 0
	fi

	if $_bindgen_wrapper_macosxHomebrewOrAlipineLinuxPackageManagerYetToBeUpdated; then
		brew update 1>&2
		brew upgrade 1>&2
		_bindgen_wrapper_macosxHomebrewOrAlipineLinuxPackageManagerYetToBeUpdated=false
	fi

	brew install "$package" "$@" 1>&2
}

bindgen_wrapper_alpineLinuxInstall()
{
	local package="$1"
	shift 1

	bindgen_wrapper_ensureRequiredBinariesArePresent "To check for the apk package '$package'" apk

	if ! apk info --installed "$package" 1>/dev/null 2>/dev/null; then
		bindgen_wrapper_ensureRequiredBinariesArePresent "To check for and, if necessary, install the apk package '$package' as root" sudo

		if $_bindgen_wrapper_macosxHomebrewOrAlipineLinuxPackageManagerYetToBeUpdated; then
			sudo -p "Enter your password to call apk update before installing package '$package': " apk update
			sudo -p "Enter your password to call apk upgrade before installing package '$package': "  apk upgrade
			_bindgen_wrapper_macosxHomebrewOrAlipineLinuxPackageManagerYetToBeUpdated=false
		fi

		sudo -p "Enter your password to call apk add to install package '$package' (you may need to enable edge and testing repositories in /etc/apk/repositories): " apk add "$package"
	fi
}

bindgen_wrapper_installBindgen()
{
	if command -v bindgen 1>/dev/null 2>/dev/null; then
		return 0
	fi

	case "$platform" in

		Darwin)
			LLVM_CONFIG_PATH=/usr/local/opt/llvm38/bin/llvm-config-3.8 LIBCLANG_PATH=/usr/local/opt/llvm38/lib/llvm-3.8/lib LIBCLANG_STATIC_PATH=/usr/local/opt/llvm38/lib/llvm-3.8/lib cargo install --git https://github.com/lemonrock/rust-bindgen.git bindgen
		;;

		Linux)
			LLVM_CONFIG_PATH=/usr/bin/llvm-config LIBCLANG_PATH=/usr/lib LIBCLANG_STATIC_PATH=/usr/lib cargo install --git https://github.com/lemonrock/rust-bindgen.git bindgen
		;;

	esac
}

bindgen_wrapper_installHeadersAndCopyOverrides()
{
	mkdir -m 0750 -p "$temporaryIncludeFolder"
	rsync --quiet --archive "$configurationFolderPath"/header-overrides/ "$headersFolderPath"/ "$temporaryIncludeFolder"/
}

bindgen_wrapper_createOutputFolder()
{
	mkdir -m 0700 -p "$outputFolderPath"
}

bindgen_wrapper_addTacFallbackIfNotPresent()
{
	# Note: tac does not exist on Mac OS X
	if ! command -v tac 1>/dev/null 2>/dev/null; then
		bindgen_wrapper_ensureRequiredBinariesArePresent "Required because 'tac' binary is not present" tail
		tac()
		{
			tail -r -- "$@"
		}
	fi
}

bindgen_wrapper_bindgen()
{
	# clangAdditionalArguments deliberately has quotes omitted
	set -- "$@" \
		--convert-macros \
		--macro-int-types=sint,sint,sint,slonglong,sint,sint,sint,slonglong \
		--use-core \
		--ctypes-prefix=XXX \
		"$temporaryIncludeFolder"/"$rootIncludeFileName" -- -I"$temporaryIncludeFolder" $clangAdditionalArguments

	case "$platform" in

		Darwin)
			local prefix="$(brew --prefix musl-cross)"
			"$_program_path"/bindgen-macosx "$@" -U__BLOCKS__ --sysroot="$prefix"/does-not-exist -isystem"$prefix"/libexec/x86_64-linux-musl/include -D__linux__
		;;

		*)
			CLANG_PATH="$llvmPrefix"/bin/clang ~/.cargo/bin/bindgen "$@" --sysroot="$prefix"/does-not-exist -isystem"$prefix"/MUSL-HEADERS-TODO -D__linux__
		;;

	esac
}

bindgen_wrapper_installPrerequisites()
{
	bindgen_wrapper_addTacFallbackIfNotPresent

	# Platform specific installation of dependencies
	local packagesToInstall
	local packageInstallFunction
	case "$platform" in

		Darwin)
			bindgen_wrapper_macosxHomebrewInstall musl-cross
			bindgen_wrapper_macosxHomebrewInstall gnu-sed
			bindgen_wrapper_macosxHomebrewInstall coreutils
			bindgen_wrapper_macosxHomebrewInstall homebrew/versions/llvm38 --with-shared-libs --with-all-targets

			packageInstallFunction=bindgen_wrapper_macosxHomebrewInstall
			packagesToInstall="$macosXHomebrewPackageNames"

			export PATH="$(brew --prefix gnu-sed)"/libexec/gnubin:"$(brew --prefix coreutils)"/libexec/gnubin:"$PATH"
		;;

		Linux)
			if [ -d ~/.cargo/bin ]; then
				export PATH=~/.cargo/bin:"$PATH"
			fi

			if bindgen_wrapper_isAlpineLinuxIfIsLinux; then

				# Provides C library headers
				# ? hmmm ?
				# bindgen_wrapper_alpineLinuxInstall musl-dev

				packageInstallFunction=bindgen_wrapper_alpineLinuxInstall
				packagesToInstall="$alpineLinuxPackageNames"
			else
				local hasRustC
				if command -v rustc 1>/dev/null 2>/dev/null; then
					hasRustC=true
				else
					hasRustC=false
				fi

				local hasCargo
				if command -v cargo 1>/dev/null 2>/dev/null; then
					hasCargo=true
				else
					hasCargo=false
				fi

				if $hasRustC; then
					if $hasCargo; then
						:
					else
						bindgen_wrapper_fail "rustc is in the PATH but not cargo; this is an unsupported combination"
					fi
				else
					if $hasCargo; then
						bindgen_wrapper_fail "cargo is in the PATH but not rustc; this is an unsupported combination"
					else
						bindgen_wrapper_ensureRequiredBinariesArePresent "Required to install rust and cargo using rustup" curl sh
						curl https://sh.rustup.rs -sSf | sh
					fi
				fi
			fi
		;;

	esac

	local IFS=' '
	local localPackageManagerPackage
	# quotes deliberately ommitted
	for localPackageManagerPackage in $packagesToInstall
	do
		$packageInstallFunction "$localPackageManagerPackage"
	done

	bindgen_wrapper_cargoBinaryInstall rustfmt
	bindgen_wrapper_installBindgen
}

bindgen_wrapper_prepend()
{
	local fileToPrepend
	for fileToPrepend in "$configurationFolderPath"/preamble.rs "$configurationFolderPath"/pre-includes.rs "$_program_path"/includes.rs "$configurationFolderPath"/post-includes.rs
	do
		if [ -s "$fileToPrepend" ]; then
			cat "$fileToPrepend"
			printf '\n'
		fi
	done
	
	local IFS=' '
	local linkValue
	local hasLinks=false
	# quotes deliberately ommitted
	for linkValue in $link
	do
		hasLinks=true
		if [ "$link_kind" = 'dynamic' ]; then
			printf '#[link(name = "%s")]\n' "$linkValue"
		else
			printf '#[link(name = "%s", kind = "%s")]\n' "$linkValue" "$link_kind"
		fi
	done
	if $hasLinks; then
		cat <<-EOF
			extern "C"
			{
			}
		EOF
	fi
}

bindgen_wrapper_rawGeneration()
{
	# Scope of bindings
	cd "$temporaryIncludeFolder" 1>/dev/null 2>/dev/null

		set --
		local wantedHeaderFile
		set +f
		for wantedHeaderFile in *.h
		do
			set -f
			set -- "$@" --match="$wantedHeaderFile"
		done
		set -f

	cd - 1>/dev/null 2>/dev/null

	bindgen_wrapper_bindgen "$@"
}

bindgen_wrapper_cleanedGeneration()
{
	local newline='\'$'\n'

	# sed line explanations:-
	# 1 - remove bindgen comment
	# 2 - remove multiline allow that (a) rustfmt can't format and (b) is no longer the first item in the file because of the use statements above and (c) is overly broad
	# 3 to 7 - remove prefixes in favour of use statements above for readability
	# 8 - suppress Copy warnings for empty enums which are types for opaque structs, format them (rustfmt can't)
	sed \
		-e '/automatically generated by rust-bindgen/d' \
		-e '/#!\[allow(dead_code,/,/non_snake_case/d' \
		-e 's/::XXX:://g' \
		-e 's/::core::clone:://g' \
		-e 's/::core::option:://g' \
		-e 's/::core::mem:://g' \
		-e 's/::core::default:://g' \
		-e 's/^pub enum \(.*\) { }/#[allow(missing_copy_implementations)]'"$newline"'#[derive(Debug)]'"$newline"'pub enum \1'"$newline"'{'"$newline"'}/g'

}

bindgen_wrapper_rustfmt()
{
	local newline='\'$'\n'

	# sed line explanations-
	# 1 - add newline before '{' in an extern block (rustfmt can't)
	# 2 - add newline before '{' in an empty enum (rustfmt can't)
	# 3 - space out better
	~/.cargo/bin/rustfmt --config-path "$_program_path"/.. | \
	sed \
		-e 's/^extern "C" {/extern "C"'"$newline"'{/g' \
		-e 's/^pub enum \(.*\) {/pub enum \1'"$newline"'{/g' \
		-e 's/^}$/}'"$newline"'/g' -e 's/^pub type \(.*\)$/pub type \1'"$newline"'/g'
}

bindgen_wrapper_renameUnnamedTypes()
{
	sed \
		-e 's/Struct_Unnamed/AnonymousStruct/g' \
		-e 's/Union_Unnamed/AnonymousUnion/g'
}

bindgen_wrapper_suppressDebugWarnings()
{
	if [ ! -s "$configurationFolderPath"/suppress-debug-warnings ]; then
		cat
		return 0
	fi

	local newline='\'$'\n'

	set --
	local struct
	while IFS='' read -r struct
	do
		# eg -e 's/pub struct lcore_config$/#[allow(missing_debug_implementations)]'"$newline"'pub struct lcore_config/g'
		set -- "$@" -e 's/pub struct '"$struct"'$/#[allow(missing_debug_implementations)]'"$newline"'pub struct '"$struct"'/g'
	done <"$configurationFolderPath"/suppress-debug-warnings

	sed "$@"
}

bindgen_wrapper_remapConstantTypes()
{
	if [ ! -s "$configurationFolderPath"/constant.types ]; then
		cat
		return 0
	fi

	set --
	local constant
	local constantRemappedType
	while IFS=' ' read -r constant constantRemappedType
	do
		# eg -e 's/pub const RTE_ETH_NAME_MAX_LEN: c_int /pub const RTE_ETH_NAME_MAX_LEN: size_t /g'
		set -- "$@" -e 's/pub const '"$constant"': [A-Za-z_][A-Za-z0-9_]* /pub const '"$constant"': '"$constantRemappedType"' /g'
	done <"$configurationFolderPath"/constant.types

	sed "$@"
}

bindgen_wrapper_generate()
{
	local temporaryIncludeFolder="$_program_path"/temporary/includes

	bindgen_wrapper_installHeadersAndCopyOverrides

	bindgen_wrapper_createOutputFolder

	bindgen_wrapper_rawGeneration >"$temporaryFolderPath"/rawGeneration

	cat "$temporaryFolderPath"/rawGeneration | bindgen_wrapper_cleanedGeneration >"$temporaryFolderPath"/cleanedGeneration

	cat "$temporaryFolderPath"/cleanedGeneration | postprocess_after_generation >"$temporaryFolderPath"/afterGeneration

	cat "$temporaryFolderPath"/afterGeneration | bindgen_wrapper_rustfmt >"$temporaryFolderPath"/rustfmt

	sed -e 's/: Enum_Unnamed[0-9]* = Enum_Unnamed[0-9]*::/: u32 = /g' "$temporaryFolderPath"/rustfmt >"$temporaryFolderPath"/unnamedenumsremoved

	cat "$temporaryFolderPath"/unnamedenumsremoved | bindgen_wrapper_renameUnnamedTypes >"$temporaryFolderPath"/rennamed-unnamed-types

	cat "$temporaryFolderPath"/rennamed-unnamed-types | bindgen_wrapper_suppressDebugWarnings >"$temporaryFolderPath"/suppress-debug-warnings

	cat "$temporaryFolderPath"/suppress-debug-warnings | bindgen_wrapper_remapConstantTypes >"$temporaryFolderPath"/remapped-constant-types

	cat "$temporaryFolderPath"/remapped-constant-types| postprocess_after_rustfmt >"$temporaryFolderPath"/afterRustfmt

	mkdir -m 0750 -p "$outputFolderPath"/types "$outputFolderPath"/enums "$outputFolderPath"/structs \
		"$outputFolderPath"/constants "$outputFolderPath"/statics "$outputFolderPath"/functions \
		"$temporaryFolderPath"/constants "$temporaryFolderPath"/statics "$temporaryFolderPath"/functions

	local namedFile=''
	local name=''
	local attributes=''
	local mode='next'
	local externC='ExpectingPubStaticMut'
	while IFS='' read -r line
	do
		case "$mode" in

			next)

				case "$line" in

					'')
						continue
					;;

					'#'*)
						if [ -z "$attributes" ]; then
							attributes="$line"
						else
							attributes="${attributes}
${line}"
						fi
					;;

					'pub const '*)
						local stripPrefix="${line#pub const }"
						local constantName="${stripPrefix%:*}"

						local chosenFileBaseName='miscellany'
						local prefix
						local fileBaseName
						while IFS=' ' read -r prefix fileBaseName
						do
							if [ -z "$fileBaseName" ]; then
								bindgen_wrapper_fail "constant.mapping prefix '$prefix' has no fileBaseName"
							fi

							case "$constantName" in

								"$prefix"*)
									chosenFileBaseName="$fileBaseName"
									break
								;;

							esac

						done <"$configurationFolderPath"/constant.mapping

						printf '%s\n' "$line" >>"$temporaryFolderPath"/constants/"$chosenFileBaseName"
					;;

					'pub type '*)
						local stripPrefix="${line#pub type }"
						name="${stripPrefix% =*}"
						printf 'include!("bindgen/types/%s");\n' "$name".rs >>"$temporaryFolderPath"/types
						namedFile="$outputFolderPath"/types/"$name".rs
						{
							cat "$configurationFolderPath"/preamble.rs
							printf '%s\n' "$line"
						} >"$namedFile"
					;;

					# We convert unnamed enums to be constant-like.
					'pub enum Enum_Unnamed'*)
						attributes=''
						mode=openBraceEnumUnnamed
					;;

					'pub enum '*)
						name="${line#pub enum }"
						printf 'include!("bindgen/enums/%s");\n' "$name".rs >>"$temporaryFolderPath"/enums
						namedFile="$outputFolderPath"/enums/"$name".rs
						{
							cat "$configurationFolderPath"/preamble.rs
							printf '%s\n' "$attributes"
							printf '%s\n' "$line"
						} >"$namedFile"
						attributes=''
						mode=openBrace
					;;

					'pub struct '*)
						name="${line#pub struct }"
						printf 'include!("bindgen/structs/%s");\n' "$name".rs >>"$temporaryFolderPath"/structs
						namedFile="$outputFolderPath"/structs/"$name".rs
						{
							cat "$configurationFolderPath"/preamble.rs
							printf '%s\n' "$attributes"
							printf '%s\n' "$line"
						} >"$namedFile"
						attributes=''
						mode=openBrace
					;;

					'impl '*)
						printf '\n%s\n' "$line" >>"$namedFile"
						mode=openBrace
					;;

					'extern "C"')

						case "$externC" in

							ExpectingPubStaticMut)
								mode=openBracePubStaticMut
							;;

							ExpectingPubFn)
								mode=openBracePubFn
							;;

							*)
								bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode' when externC '$externC'"
							;;

						esac
					;;

					*)
						bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
					;;

				esac
			;;

			openBrace)
				if [ "$line" != '{' ]; then
					bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
				fi
				printf '%s\n' "$line" >>"$namedFile"
				mode=closeBrace
			;;

			closeBrace)
				if [ "$line" = '}' ]; then
					mode=next
				fi
				printf '%s\n' "$line" >>"$namedFile"
			;;

			openBraceEnumUnnamed)
				if [ "$line" != '{' ]; then
					bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
				fi
				mode=closeBraceEnumUnnamed
			;;

			closeBraceEnumUnnamed)
				if [ "$line" = '}' ]; then
					mode=next
				else
					local unnamedEnumName
					local unnamedEnumValue
					local remainder
					IFS=$'\t'" =," read -r unnamedEnumName unnamedEnumValue remainder <<-EOF
						${line}
					EOF

					local chosenFileBaseName='unnamed-enum'
					local prefix
					local fileBaseName
					while IFS=' ' read -r prefix fileBaseName
					do
						if [ -z "$fileBaseName" ]; then
							bindgen_wrapper_fail "unnamed-enum.mapping prefix '$prefix' has no fileBaseName"
						fi

						case "$unnamedEnumName" in

							"$prefix"*)
								chosenFileBaseName="$fileBaseName"
								break
							;;

						esac

					done <"$configurationFolderPath"/unnamed-enum.mapping

					printf 'pub const %s: %s = %s;\n' "$unnamedEnumName" 'u32' "$unnamedEnumValue" >>"$temporaryFolderPath"/constants/"$chosenFileBaseName"
				fi

			;;

			openBracePubStaticMut)
				if [ "$line" != '{' ]; then
					bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
				fi
				mode=closeBracePubStaticMut
			;;

			closeBracePubStaticMut)
				if [ "$line" = '}' ]; then
					mode=next
					externC=ExpectingPubFn
				else
					local field_pub
					local field_static
					local field_mut
					local staticName
					local remaining
					IFS=$'\t'" :" read -r field_pub field_static field_mut staticName remaining <<-EOF
						${line}
					EOF

					local chosenFileBaseName='miscellany'
					local prefix
					local fileBaseName
					while IFS=' ' read -r prefix fileBaseName
					do
						if [ -z "$fileBaseName" ]; then
							bindgen_wrapper_fail "static.mapping prefix '$prefix' has no fileBaseName"
						fi

						case "$staticName" in

							"$prefix"*)
								chosenFileBaseName="$fileBaseName"
								break
							;;

						esac

					done <"$configurationFolderPath"/static.mapping

					printf '%s\n' "$line" >>"$temporaryFolderPath"/statics/"$chosenFileBaseName"
				fi
			;;

			openBracePubFn)
				if [ "$line" != '{' ]; then
					bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
				fi
				mode=closeBracePubFn
			;;

			closeBracePubFn)
				if [ "$line" = '}' ]; then
					mode=next
				else
					local field_pub
					local field_fn
					local functionName
					local remaining
					IFS=$'\t'" (" read -r field_pub field_fn functionName remaining <<-EOF
						${line}
					EOF

					local chosenFileBaseName='miscellany'
					local prefix
					local fileBaseName
					while IFS=' ' read -r prefix fileBaseName
					do
						if [ -z "$fileBaseName" ]; then
							bindgen_wrapper_fail "function.mapping prefix '$prefix' has no fileBaseName"
						fi

						case "$functionName" in

							"$prefix"*)
								chosenFileBaseName="$fileBaseName"
								break
							;;

						esac

					done <"$configurationFolderPath"/function.mapping

					printf '%s\n' "$line" >>"$temporaryFolderPath"/functions/"$chosenFileBaseName"
				fi
			;;

			*)
				bindgen_wrapper_fail "Did not expect line '$line' when in mode '$mode'"
			;;

		esac

	done <"$temporaryFolderPath"/afterRustfmt

	{
		bindgen_wrapper_prepend

		printf '\n'

		printf 'include!("bindgen/constants.rs");\n'
		cat "$configurationFolderPath"/preamble.rs >>"$outputFolderPath"/constants.rs
		cd "$temporaryFolderPath"/constants 1>/dev/null 2>/dev/null

			set +f
			local constantsSetFile
			for constantsSetFile in *
			do
				set -f

				printf 'include!("bindgen/constants/%s.rs");\n' "$constantsSetFile" >>"$temporaryFolderPath"/constant-sets

				{
					cat "$configurationFolderPath"/preamble.rs
					LC_ALL=en_US.UTF-8 sort "$constantsSetFile"
				} >"$outputFolderPath"/constants/"$constantsSetFile".rs
			done
			set -f

		cd - 1>/dev/null 2>/dev/null
		LC_ALL=en_US.UTF-8 sort "$temporaryFolderPath"/constant-sets >>"$outputFolderPath"/constants.rs
		rm -rf "$temporaryFolderPath"/constant-sets "$temporaryFolderPath"/constants

		printf 'include!("bindgen/types.rs");\n'
		cat "$configurationFolderPath"/preamble.rs >>"$outputFolderPath"/types.rs
		LC_ALL=en_US.UTF-8 sort "$temporaryFolderPath"/types >>"$outputFolderPath"/types.rs
		rm -rf "$temporaryFolderPath"/types

		printf 'include!("bindgen/enums.rs");\n'
		cat "$configurationFolderPath"/preamble.rs >>"$outputFolderPath"/enums.rs
		LC_ALL=en_US.UTF-8 sort "$temporaryFolderPath"/enums >>"$outputFolderPath"/enums.rs
		rm -rf "$temporaryFolderPath"/enums

		printf 'include!("bindgen/structs.rs");\n'
		cat "$configurationFolderPath"/preamble.rs >>"$outputFolderPath"/structs.rs
		LC_ALL=en_US.UTF-8 sort "$temporaryFolderPath"/structs >>"$outputFolderPath"/structs.rs
		rm -rf "$temporaryFolderPath"/structs

		printf 'include!("bindgen/statics.rs");\n'
		cat "$configurationFolderPath"/preamble.rs >>"$outputFolderPath"/statics.rs
		cd "$temporaryFolderPath"/statics 1>/dev/null 2>/dev/null

			set +f
			local staticsSetFile
			for staticsSetFile in *
			do
				set -f

				printf 'include!("bindgen/statics/%s.rs");\n' "$staticsSetFile" >>"$temporaryFolderPath"/static-sets

				{
					cat "$configurationFolderPath"/preamble.rs
					printf 'extern "C"\n{\n'
					LC_ALL=en_US.UTF-8 sort "$staticsSetFile"
					printf '}\n'
				} >"$outputFolderPath"/statics/"$staticsSetFile".rs
			done
			set -f

		cd - 1>/dev/null 2>/dev/null
		LC_ALL=en_US.UTF-8 sort "$temporaryFolderPath"/static-sets >>"$outputFolderPath"/statics.rs
		rm -rf "$temporaryFolderPath"/static-sets "$temporaryFolderPath"/statics

		printf 'include!("bindgen/functions.rs");\n'
		cat "$configurationFolderPath"/preamble.rs >>"$outputFolderPath"/functions.rs
		cd "$temporaryFolderPath"/functions 1>/dev/null 2>/dev/null

			set +f
			local functionsSetFile
			for functionsSetFile in *
			do
				set -f

				printf 'include!("bindgen/functions/%s.rs");\n' "$functionsSetFile" >>"$temporaryFolderPath"/function-sets

				{
					cat "$configurationFolderPath"/preamble.rs
					printf 'extern "C"\n{\n'
					LC_ALL=en_US.UTF-8 sort "$functionsSetFile"
					printf '}\n'
				} >"$outputFolderPath"/functions/"$functionsSetFile".rs
			done
			set -f

		cd - 1>/dev/null 2>/dev/null
		LC_ALL=en_US.UTF-8 sort "$temporaryFolderPath"/function-sets >>"$outputFolderPath"/functions.rs
		rm -rf "$temporaryFolderPath"/function-sets "$temporaryFolderPath"/functions

	} >"$outputFolderPath"/lib.rs





	# Tidy up #[derive]; combine Debug, add additionally valid options
	local enumOrStructFile
	set +f
	for enumOrStructFile in "$outputFolderPath"/enums/*.rs "$outputFolderPath"/structs/*.rs
	do
		set -f

		if grep -q '^#\[derive(Copy, Clone)\]$' "$enumOrStructFile"; then
			if grep -q '^#\[derive(Debug)\]$' "$enumOrStructFile"; then
				sed -i -e '/^#\[derive(Copy, Clone)\]$/d' -e '/^#\[derive(Debug)\]$/d' -e 's/^pub /#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub /g' "$enumOrStructFile"
			fi
		fi
	done
	set -f



	# Add inline annotations to clone default
	local structFile
	set +f
	for structFile in "$outputFolderPath"/structs/*.rs
	do
		set -f

		sed -i \
			-e 's/\tfn clone(\&self) -> Self/\t#[inline(always)]\n\tfn clone(\&self) -> Self/g' \
			-e 's/\tfn default() -> Self/\t#[inline(always)]\n\tfn default() -> Self/g' \
			"$structFile"
	done
	set -f
	
	
	
	bindgen_wrapper_remove_equality_derives_from_structs
	
	bindgen_wrapper_remove_debug_derives_from_structs

	bindgen_wrapper_extract_opaque_pointers_from_enums
	
	final_chance_to_tweak
}

bindgen_wrapper_remove_equality_derives_from_structs()
{
	local dataFilePath="$configurationFolderPath"/remove-equality-derives-from-structs
	if [ ! -s "$dataFilePath" ]; then
		return 0
	fi
	
	cd "$outputFolderPath"/structs 1>/dev/null 2>/dev/null
		
		local structName
		while IFS= read -r structName
		do
			local fileName="$structName".rs
			if [ ! -f "$fileName" ]; then
				bindgen_wrapper_fail "Can not remove-equality-derives-from-structs for struct '$structName'"
			fi
			sed -i -e 's;, PartialEq, Eq, PartialOrd, Ord, Hash;;g' "$fileName"
		done <"$dataFilePath"
		
	cd - 1>/dev/null 2>/dev/null
}

bindgen_wrapper_remove_debug_derives_from_structs()
{
	local dataFilePath="$configurationFolderPath"/remove-debug-derives-from-structs
	if [ ! -s "$dataFilePath" ]; then
		return 0
	fi
	
	cd "$outputFolderPath"/structs 1>/dev/null 2>/dev/null
		
		local structName
		while IFS= read -r structName
		do
			local fileName="$structName".rs
			if [ ! -f "$fileName" ]; then
				bindgen_wrapper_fail "Can not remove-equality-derives-from-structs for struct '$structName'"
			fi
			sed -i -e 's;, Debug;;g' -e 's;#\[derive;#[allow(missing_copy_implementations)]\n#[derive;g' "$fileName"
		done <"$dataFilePath"
		
	cd - 1>/dev/null 2>/dev/null
}

bindgen_wrapper_extract_opaque_pointers_from_enums()
{
	local opaqueStructName
	cd "$outputFolderPath"/enums 1>/dev/null 2>/dev/null
		
		set +f
			set -- *.rs
		set -f
	
		mkdir -m 0700 -p "$outputFolderPath"/opaques
		
		{
			cat "$configurationFolderPath"/preamble.rs
			grep '^#\[allow(missing_copy_implementations)\]' "$@" | awk -F. '{print $1}' | LC_ALL=C sort -u | while IFS= read -r opaqueStructName
			do
				sed -i -e 's;include!("bindgen/enums/'"$opaqueStructName"'.rs");DELETEME;g' -e '/DELETEME/d' "$outputFolderPath"/enums.rs
			
				printf 'include!("bindgen/opaques/%s.rs");\n' "$opaqueStructName"
			
				mv "$outputFolderPath"/enums/"$opaqueStructName".rs "$outputFolderPath"/opaques
			done
		} >"$outputFolderPath"/opaques.rs

		printf 'include!("bindgen/opaques.rs");\n' >>"$outputFolderPath"/lib.rs
		
	cd - 1>/dev/null 2>/dev/null
}

bindgen_wrapper_sourceConfigurationThenExecute()
{
	local functionToExecute="$1"
	shift 1

	local configurationFolderPath="$homeFolder"/bindgen-wrapper.conf.d
	local configurationFilePath="$configurationFolderPath"/configuration.sh
	if [ ! -s "$configurationFilePath" ]; then
		bindgen_wrapper_fail "Configuration file '$configurationFilePath' is not present, not readable or empty"
	fi
	local bindingsName
	local rootIncludeFileName
	local link
	local link_kind='dynamic'
	local macosXHomebrewPackageNames
	local alpineLinuxPackageNames

	local headersFolderPath=''
	local clangAdditionalArguments=''
	preprocess_before_headersFolderPath()
	{
		cat
	}
	postprocess_after_generation()
	{
		cat
	}
	postprocess_after_rustfmt()
	{
		cat
	}
	final_chance_to_tweak()
	{
		:
	}
	. "$configurationFolderPath"/configuration.sh

	if [ -z "$headersFolderPath" ]; then
		headersFolderPath="$prefix"/include/"$bindingsName"
	fi

	$functionToExecute "$@"
}

bindgen_wrapper_execute()
{
	bindgen_wrapper_installPrerequisites
	preprocess_before_headersFolderPath
	bindgen_wrapper_generate
}

bindgen_wrapper_setAbsoluteProgramPathAndHomeFolder()
{
	_program_path="$(_program_path_find)"
	cd "$_program_path"/../.. 1>/dev/null 2>/dev/null
		homeFolder="$(pwd -P)"
	cd - 1>/dev/null 2>/dev/null
}

bindgen_wrapper_main()
{
	bindgen_wrapper_ensureRequiredBinariesArePresent "Required for basic operation" uname rm mkdir cat sed sort grep

	bindgen_wrapper_setAbsoluteProgramPathAndHomeFolder

	local temporaryFolderPath="$_program_path"/temporary
	rm -rf "$temporaryFolderPath"
	mkdir -m 0750 -p "$temporaryFolderPath"

	local outputFolderPath="$_program_path"/../../src/bindgen
	rm -rf "$outputFolderPath"

	# Platform variations that can be overridden by configuration
	local platform="$(uname)"
	case "$platform" in

		Darwin)
			bindgen_wrapper_ensureRequiredBinariesArePresent "Required for basic operation on Mac OS X" brew
			local prefix="$(brew --prefix)"
			local llvmPrefix="$(brew --prefix llvm)"
		;;

		Linux)
			local prefix='/usr'
			local llvmPrefix="$prefix"
		;;

		*)
			bindgen_wrapper_fail "Unsupported platform '$platform'"
		;;

	esac

	bindgen_wrapper_sourceConfigurationThenExecute bindgen_wrapper_execute
}

bindgen_wrapper_main "$@"
